# **Chapter-04**

타입 설계

## Table of contents
- [28. 유효한 상태만 표현하는 타입을 지향하기](#28-유효한-상태만-표현하는-타입을-지향하기)
- [29. 사용할 때는 너그럽게, 생성할 때는 엄격하게](#29-사용할-때는-너그럽게-생성할-때는-엄격하게)
- [30. 문서에 타입 정보를 쓰지 않기](#30-문서에-타입-정보를-쓰지-않기)
- [31. 타입 주변에 null 값 배치하기](#31-타입-주변에-null-값-배치하기)
- [32. 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기](#32-유니온의-인터페이스보다는-인터페이스의-유니온을-사용하기)
- [33. string 타입보다 더 구체적인 타입 사용하기](#33-string-타입보다-더-구체적인-타입-사용하기)
- [34. 부정확한 타입보다는 미완성 타입을 사용하기](#34-부정확한-타입보다는-미완성-타입을-사용하기)
- [35. 데이터가 아닌, API 명세를 보고 타입 만들기](#35-데이터가-아닌-api-명세를-보고-타입-만들기)
- [36. 해당 분야의 용어로 타입 이름 짓기](#36-해당-분야의-용어로-타입-이름-짓기)
- [37. 공식 명칭에는 상표를 붙이기](#37-공식-명칭에는-상표를-붙이기)

---

## **28. 유효한 상태만 표현하는 타입을 지향하기**

### 요약
- 유효한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고, 오류를 유발하게 됨
- 유효한 상태만 표현하는 타입을 지향해야 함
  - 코드가 길어지거나 표현이 어려워지지만 결국 시간을 절약하고, 고통을 줄일 수 있음

#### 효과적으로 타입을 설계하기
- 효과적으로 타입을 설계하려면 유효한 상태만 표현할 수 있는 타입을 만들어야 함


## **29. 사용할 때는 너그럽게, 생성할 때는 엄격하게**

### 요약
- 보통 매개변수 타입은 반환 타입에 비해 범위가 넓은 경향이 있음
  - 선택적 속성과 유니온 타입은 반환 타입보다 매개변수 타입에 더 일반적
- 매개변수와 반환 타입의 재사용을 위해서 기본 형태(반환 타입)와 느슨한 형태(매개변수 타입)를 도입하는 것이 좋음

## **30. 문서에 타입 정보를 쓰지 않기**

### 요약
- 주석과 변수명에 타입 정보를 적는 것은 피해야 함
  - 타입 선언이 중복되는 것으로 끝나면 다행이지만 최악의 경우는 타입 정보에 모슨이 발생
- 타입이 명확하지 않은 경우는 변수명에 **단위 정보**를 포함하는 것을 고려하는 것이 좋음


### 코드와 주석의 정보가 맞지 않는다면 둘 다 잘못된 것! 🤔 👀

```ts
/**
 *
 * 전경색(foregroundcolor) 문자열을 반환 - ❌ 실제로는 객체 반환
 * 0개 또는 1개의 매개변수를 받음  - ❌ 이미 코드(타입 시그니처)에 의해 표현된 정보
 * 매개변수가 없을 때는 표준 전경색 반환
 * 매개변수가 있을 때는 특정 페이지의 전경색 반환
 */
const getForegroundColor = (page?: string) => {
  return page === 'login' ? { r: 127, g: 127, b: 127 } : { r: 0, g: 0, b: 0 };
};
```

#### 잘못된 주석
 - 전경색(foregroundcolor) 문자열을 반환 - ❌ 실제로는 객체 반환
 - 0개 또는 1개의 매개변수를 받음  - ❌ 이미 코드(타입 시그니처)에 의해 표현된 정보
 - 매개변수가 없을 때는 표준 전경색 반환 - ❌ 불필요하게 장황, 핵심을 설명하지 못함
 - 매개변수가 있을 때는 특정 페이지의 전경색 반환


#### 타입 정보를 쓰지 않은 올바른 주석 표기

```ts
/** 애플리케이션 또는 특정 페이지의 전경색을 가져옴 */
const getForegroundColor = (page: string) => {
  return page === 'login' ? { r: 127, g: 127, b: 127 } : { r: 0, g: 0, b: 0 };
};
```

---

## **31. 타입 주변에 null 값 배치하기**

### 요약
- 한 값의 null 여부가 다른 값의 null 여부에 암시적으로 관련되도록 설계하면 안됨
- API 작성 시에는 반환 타입을 큰 객체로 만들고, 반환 타입 전체가 null 이거나 null이 아니게 만들어야 함
 - 이러한 방식을 따르면, 사람과 타입 검사기 모두에게 명료한 코드가 됨
- 클래스를 만들 때는 필요한 모든 값이 준비되었을 때 생성하여 null이 존재하지 않도록 하는 것이 좋음
- strictNullChecks 를 설정하면 코드에 많은 오류가 표시되지만, null값과 관련된 문제점을 찾을 수 있으므로 반드시 필요


## **32. 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기**

### 요약
- 유니온 타입의 속성을 여러 개 가지는 인터페이스에서는 속성 간의 관계가 분명하지 않으므로 실수가 자주 발생함
- 유니온의 인터페이스보다 인터페이스의 유니온이 더 정확하고, 타입스크립트가 이해하기도 좋음
- 타입스크립트가 제어 흐름을 분석할 수 있도록 타입에 태그 넣는 것을 고려해야 함
  - 태그된 유니온은 타입스크립트와 매우 맞기 때문에 자주 볼 수 있는 패턴

#### 유니온의 인터페이스
아래의 코드에서 fill과 함께 LineLayout과 PointPaint 타입이 쓰이는 것은 말이 되지 않음 🥲

```ts
interface Layer {
  type: 'fill' | 'line' | 'point;
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}
```

#### 인터페이스의 유니온으로 변환
fill과 함께 LineLayout과 PointPaint 타입이 쓰이는 것을 방지하기 위해 Layer를 인터페이스의 유니온으로 변환

```ts
interface Layer {
  type: 'fill' | 'line' | 'point;
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}

interface FillLayer {
  type: 'fill';
  layout: FillLayout;
  paint: FillPaint;
}

interface LineLayer {
  type: 'line';
  layout: LineLayout;
  paint: LinePaint;
}

interface PointLayer {
  type: 'point';
  layout: PointLayout;
  paint: PointPaint;
}

type Layer = FillLayer | LineLayer | PointLayer;
```

## **33. string 타입보다 더 구체적인 타입 사용하기**

### 요약
- 문자열을 남발하여 선언된 코드를 피하자
  - 모든 문자열을 할당할 수 있는 string 보다 더 구체적인 타입을 사용하는 것이 좋음
- 변수의 범위를 정확하게 표현하고 싶다면 리터럴 타입의 유니온을 사용하자
  - 타입 체크를 더 엄격히 할 수 있고, 생산성을 향상시킬 수 있음
- 객체의 속성 이름을 함수 매개변수로 받을 때는 string보다 keyof T 를 사용하는 것이 좋음


#### string을 타입을 남발할 때 문제점

```ts
const recordRelease = (title: string, date: string) => {
  console.log('Recording album...');
};

recordRelease('1959-08-17', 'Kind of Blue');
```

## **34. 부정확한 타입보다는 미완성 타입을 사용하기**

### 요약
- 타입 안정성에 대한 불쾌한 골짜기는 피해야 함. 타입이 없는 것보다 잘못된 것이 더 나쁨
- 정확하게 타입을 모델링할 수 없다면 부정확하게 모델링하지 말아야 함

---

## **35. 데이터가 아닌, API 명세를 보고 타입 만들기**

### 요약
- 코드의 구석구석까지 타입 안정성을 얻기 위해 API 또는 데이터 형식에 대한 타입 생성을 고려해야 함
- 데이터에 드러나지 않은 예외적인 경우들이 문제가 될 수 있으므로 명세로부터 코드를 생성하는 것이 좋음

---

## **36. 해당 분야의 용어로 타입 이름 짓기**

### 요약
- 가독성을 높이고, 추상화 수준을 올리기 위해 해당 분야의 용어를 사용해야 함
  - 타입 이름 짓기 역시 중요한 영역
  - 엄선된 타입, 속성, 변수의 이름은 의도를 명확히하고, 코드와 타입의 추상화 수준을 높여줌
- 같은 의미에서 다른 이름을 붙이면 안 됨.
  - 특별한 의미가 있을 때만 용어를 구분

### 정리
- 동일한 의미를 나타낼 때는 같은 용어의 사용
- 모호하고, 의미없는 이름은 피해야 함
- 이름을 지을 때는 데이터 자체가 무엇인지 고려해야 함

---

## **37. 공식 명칭에는 상표를 붙이기**

### 요약
- 타입스크립트는 구조적 타이핑을 사용하므로 값을 세밀하게 구분하지 못하는 경우가 있음
  - 값을 구분하기 위해 공식 명칭이 필요하다면 상표(brand)를 붙이는 것을 고려해야 함
- 상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있음

### 상표(_brand)를 사용하면 단순한 실수를 방지할 수 있다. 
물론 악의적인 사용을 막을 수는 없음

```ts
interface Vector2D {
  x: number;
  y: number;
  _brand: '2d';
}

const vector2D = (x: number, y: number): Vector2D => {
  return { x, y, _brand: '2d' };
};

const calculateNorm = (p: Vector2D) => {
  return Math.sqrt(p.x * p.x + p.y * p.y); // 기존과 동일
};

calculateNorm(vector2D(3, 4)); // 5
const vec3D = { x: 3, y: 4, z: 1 };

calculateNorm(vec3D); // 5
```