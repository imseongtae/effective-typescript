# **Chapter-06**

any 다루기

## Table of contents
- [45. devDependencies에 TypeScript와 @types 추가하기](#45-devdependencies에-typescript와-types-추가하기)
- [46. 타입 선언과 관련된 3가지 버전 이해하기](#46-타입-선언과-관련된-3가지-버전-이해하기)
- [47. 공개 API에 등장하는 모든 타입을 익스포트하기](#47-공개-api에-등장하는-모든-타입을-익스포트하기)
- [49. 콜백에서 this에 대한 타입 제공하기](#49-콜백에서-this에-대한-타입-제공하기)
- [50. 오버로딩된 타입보다는 조건부 타입을 사용하기](#50-오버로딩된-타입보다는-조건부-타입을-사용하기)
- [51. 의존성 분리를 위해 미러 타입 사용하기](#51-의존성-분리를-위해-미러-타입-사용하기)
- [52. 테스팅 타입의 함정에 주의하기](#52-테스팅-타입의-함정에-주의하기)

---

## **45. devDependencies에 TypeScript와 @types 추가하기**

### 요약
- 타입스크립트를 시스템 레벨로 설치하면 안됨
  - 타입스크립트를 프로젝트의 devDependencies에 포함시키고, 팀원 모두가 동일한 버전을 사용하도록 해야 함
- @types 의존성은 dependencies가 아니라 devDependencies에 포함시켜야 함
  - 런타임에 @types가 필요한 경우라면 별도의 작업이 필요할 수 있음

## **46. 타입 선언과 관련된 3가지 버전 이해하기**

### 요약
- @types 의존성과 관련된 3가지 버전이 있음
  - 라이브러리 버전, @types 버전, 타입스크립트 버전
- 라이브러리를 업데이트하는 경우, 해당 @types 역시 업데이트해야 함
- 타입 선언을 라이브러리에 포함하는 것과 DefinitelyTyped에 공개하는 것 사이의 장단점을 이해해야 함
  - 타입스크립트로 작성된 라이브러리라면 타입 선언을 자체적으로 포함하고, 자바스크립트로 작성된 라이브러리라면 타입 선언을 DefinitelyTyped에 공개하는 것이 좋음

## **47. 공개 API에 등장하는 모든 타입을 익스포트하기**

### 요약
- 공개 메서드에 등장한 어떤 형태의 타입이든 익스포트하기
  - 어차피 라이브러리 사용자가 추출할 수 있으므로, 익스포트하기 쉽게 만드는 것이 좋음

## **48. API 주석에 TSDoc 사용하기**

```ts
/** 인사말을 생성합니다. 결과는 보기 좋게 꾸며집니다. */
function greetJSDoc(name: string, title: string) { 
  return `Hello ${title} ${name}`;
}
```

```ts
/** 특정 시간과 장소에서 수행된 측정 */
interface Measurement {
  /** 어디에서 측정되었나? */
  position: Vector3D;
  /** 언제 측정되었나? epoch에서부터 초 단위로. */ 
  time: number;
  /** 측정된 운동량 */
  momentum: Vector3D;
}
```


### 요약
- 익스포트된 함수, 클랙스, 타입에 주석을 달 때는 JSDoc-/TSDoc 형태를 사용
  - JSDoc-/TSDoc 형태의 주석을 달면 편집기가 주석 정보를 표시
- 문서 서식을 위해 @param, @returns 구문과 마크다운(Markdown)을 사용할 수 있음
- 주석에 타입 정보를 포함하면 안 됨

---

## **49. 콜백에서 this에 대한 타입 제공하기**

### this는 혼란스러운 기능
- let, const 로 선언된 변수는 렉시컬 스코프(lexical scope)
- this는 다이나믹 스코프
  - 다이나믹 스코프의 값은 정의된 방식이 아니라 호출된 방식에 따라 달라짐
  - this는 객체의 현재 인스턴스를 참조하는 클래스에서 많이 쓰임


#### this의 까다로운 면모에 대한 예제

- c.logSquares() 는 실제로 두 가지 작업을 함
  - c.prototype.logSquares 호출
  - this의 값을 c로 바인딩

```ts
const c = new C();
const method = c.logSquares();
```

아래와 같이 한번에 일어나는 두 가지 작업을 분리하면 this의 값은 undefined가 됨

```ts
const c = new C();
// NOTE: 외부 변수를 넣고 호출하면 에러가 발생함
const method = c.logSquares;
method(); //  Cannot read properties of undefined (reading 'vals')
```

#### 자바스크립트에서 this 바인딩을 제어하는 방법
call 을 사용하여 명시적으로 this를 바인딩


#### this 바인딩을 더 간단하게 해결하는 방법
화살표 함수를 사용하면, 인스턴스가 생성될 때마다 바인딩된 this를 갖는 새 함수를 생성하게 됨


### 타입스크립트도 this바인딩을 그대로 모델링함
만약 작성 중인 라이브러리에서 this를 사용하는 콜백함수가 있다면, this 바인딩을 고려해야 함


### 요약
- this 바인딩이 동작하는 원리를 이해해야 함
- 콜백 함수에서 this를 사용해야 한다면, 타입 정보를 명시해야 함


## **50. 오버로딩된 타입보다는 조건부 타입을 사용하기**


### 제너릭 사용


### 여러 가지 타입 선언으로 분리


### 조건부 타입의 사용
조건부 타입은 삼항 연산자처럼 사용하면 됨

### 요약
- 오버로딩된 타입보다는 조건부 타입을 사용하는 것이 좋음
  - 조건부 타입은 추가적인 오버로딩 없이 유니온 타입을 지원할 수 있음


## **51. 의존성 분리를 위해 미러 타입 사용하기**
- 미러링 기법은 유닛 테스트와 상용 시스템 간의 의존성을 분리하는데 유용

### 요약
- 필수가 아닌 의존성을 분리할 때는 구조적 타이핑을 사용하면 됨
- 공개한 라이브러리를 사용하는 자바스크립트 사용자가 @types 의존성을 가지지 않게 해야 함
  - 그리고 웹 개발자가 Nodejs 관련 의존성을 갖지 않도록 해야 함

---

## **52. 테스팅 타입의 함정에 주의하기**
- 타입 선언을 테스팅한다는 것은 어렵지만 해야 하는 작업
- dtslint 같은 도구를 사용하는 것

### 요약
- 타입을 테스트할 때는 특히 함수 타입의 동일성과 할당 가능성의 차이점을 알고 있어야 함
- 콜백이 있는 함수를 테스트할 때, 콜백 매개변수의 추론된 타입을 체크해야 함
  - 또한 this가 API의 일부분이라면 역시 테스트해야 함
- 타입 관련된 테스트에서 any를 주의해야 함
  - 더 엄격한 테스트를 dtslint 같은 도구를 사용하는 것이 좋음
