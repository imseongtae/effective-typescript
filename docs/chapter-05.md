# **Chapter-05**

any 다루기

## Table of contents
- [38. any 타입은 가능한 한 좁은 범위에서만 사용하기](#38-any-타입은-가능한-한-좁은-범위에서만-사용하기)
- [39. any를 구체적으로 변형해서 사용하기](#39-any를-구체적으로-변형해서-사용하기)
- [40. 함수 안으로 타입 단언문 감추기](#40-함수-안으로-타입-단언문-감추기)
- [41. any의 진화를 이해하기](#41-any의-진화를-이해하기)
- [42. 모르는 타입의 값에는 any 대신 unknown을 사용하기](#42-모르는-타입의-값에는-any-대신-unknown을-사용하기)
- [43. 몽키 패치보다는 안전한 타입을 사용하기](#43-몽키-패치보다는-안전한-타입을-사용하기)
- [44. 타입 커버리지를 추적하여 타입 안전성 유지하기](#44-타입-커버리지를-추적하여-타입-안전성-유지하기)

---

## **34. 부정확한 타입보다는 미완성 타입을 사용하기**

### 요약
- 타입 안정성에 대한 불쾌한 골짜기는 피해야 함. 타입이 없는 것보다 잘못된 것이 더 나쁨
- 정확하게 타입을 모델링할 수 없다면 부정확하게 모델링하지 말아야 함

---

## **35. 데이터가 아닌, API 명세를 보고 타입 만들기**

### 요약
- 코드의 구석구석까지 타입 안정성을 얻기 위해 API 또는 데이터 형식에 대한 타입 생성을 고려해야 함
- 데이터에 드러나지 않은 예외적인 경우들이 문제가 될 수 있으므로 명세로부터 코드를 생성하는 것이 좋음

---

## **36. 해당 분야의 용어로 타입 이름 짓기**

### 요약
- 가독성을 높이고, 추상화 수준을 올리기 위해 해당 분야의 용어를 사용해야 함
  - 타입 이름 짓기 역시 중요한 영역
  - 엄선된 타입, 속성, 변수의 이름은 의도를 명확히하고, 코드와 타입의 추상화 수준을 높여줌
- 같은 의미에서 다른 이름을 붙이면 안 됨.
  - 특별한 의미가 있을 때만 용어를 구분

### 정리
- 동일한 의미를 나타낼 때는 같은 용어의 사용
- 모호하고, 의미없는 이름은 피해야 함
- 이름을 지을 때는 데이터 자체가 무엇인지 고려해야 함

---

## **37. 공식 명칭에는 상표를 붙이기**

### 요약
- 타입스크립트는 구조적 타이핑을 사용하므로 값을 세밀하게 구분하지 못하는 경우가 있음
  - 값을 구분하기 위해 공식 명칭이 필요하다면 상표(brand)를 붙이는 것을 고려해야 함
- 상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있음

### 상표(_brand)를 사용하면 단순한 실수를 방지할 수 있다. 
물론 악의적인 사용을 막을 수는 없음

```ts
interface Vector2D {
  x: number;
  y: number;
  _brand: '2d';
}

const vector2D = (x: number, y: number): Vector2D => {
  return { x, y, _brand: '2d' };
};

const calculateNorm = (p: Vector2D) => {
  return Math.sqrt(p.x * p.x + p.y * p.y); // 기존과 동일
};

calculateNorm(vector2D(3, 4)); // 5
const vec3D = { x: 3, y: 4, z: 1 };

calculateNorm(vec3D); // 5
```



## **38. any 타입은 가능한 한 좁은 범위에서만 사용하기**

### 요약
- 의도치 않은 타입 안전성의 손실을 피하기 위해서 `any`의 사용 범위를 최소한으로 좁혀야 함
- 함수의 반환 타입이 `any`인 경우 타입 안정성이 나빠짐
  - 절대로 `any` 타입을 반환하면 안 됨
- 강제로 타입 오류를 제거하려면 `any` 대신 `@ts-ignore` 를 사용하는 것이 좋음

## **39. any를 구체적으로 변형해서 사용하기**

### 요약
- `any`를 사용할 때는 정말로 모든 값이 허용되어야만 하는지 면밀히 검토해야 함
- `any`보다 더 정확하게 모델링할 수 있도록 `any[]` 또는 `{[]: any}` 또는 `() => any`처럼 구체적인 형태를 사용해야 함


### 되도록 구체적으로 사용하자
- 함수내의 array.length 타입이 체크됨
- 함수의 반환 타입이 추론됨
- 함수 호출시 매개변수가 배열인지 체크됨

```ts
const getLength = (array: any[]) => array.length;
```

---

## **40. 함수 안으로 타입 단언문 감추기**

### 요약
- 타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 필요하기도 하고, 현실적인 해결책이 되기도 함
  - 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 해야 함

```ts
interface MyObject {
  [key: string]: any;
}

const isEqual = (obj1: MyObject, obj2: MyObject): boolean => {
  for (const key in obj1) {
    if (obj1.hasOwnProperty(key)) {
      // 단언문 사용
      const val1 = obj1[key];
      const val2 = obj2[key];

      // 객체의 동일한 키에 대해 값이 같은지 확인
      if (val1 !== val2) {
        return false;
      }
    }
  }
  return true;
};

const objA = { a: 1, b: '2' };
const objB = { a: 1, b: '2' };

console.log(isEqual(objA, objB)); // true
```

---

## **41. any의 진화를 이해하기**
any 타입의 진화는 암시적 any 타입에 어떤 값을 할당할 때만 발생.
어떤 변수가 암시적 any 상태일 때 값을 읽으려고 하면 오류가 발생함

### 요약
- 일반적인 타입들은 정제되기만 하는 반면 암시적 any와 any[] 타입은 진화할 수 있음
- any를 진화시키는 방식보다 **명시적 타입 구문**을 사용하는 것이 안전한 타입을 유지하는 방법임

## **42. 모르는 타입의 값에는 any 대신 unknown을 사용하기**

### 할당 가능성 관점에서 any 이해하기
1. 어떠한 타입이든 any 타입에 할당 가능하다
2. any 타입은 어떠한 타입으로도 할당 가능하다

'타입을 값의 집합으로 생각하기(아이템 7)'의 관점에서, 한 집합은 다른 모든 집합의 부분 집합이면서 동시에 상위 집합이 될 수 없으므로, 분명히 any는 타입 시스템과 상충되는 면을 가지고 있는데 이러한 지점이 any의 강력함의 원천이면서 동시에 문제를 일으키는 원인이 된다. 타입 체커는 집합 기반이므로 any를 사용하면 타입 체커가 무용지물이 된다는 것을 주의해야 함

### unknown 의 이해
unknown 은 any의 첫 번째 속성(어떠한 타입이든 any 타입에 할당 가능)을 만족하지만, 두 번째 속성(any 타입은 어떠한 타입으로도 할당 가능하다)은 만족하지 않는다.

그래서 unknown을 사용하기 위해서는 사용자가 직접 단언문을 사용하거나 원하는대로 타입을 좁히도록 강제하는 것이 좋음

### 변수 선언과 관련된 unknown
unknown 타입의 범위를 좁히기 위해서는 상당히 많은 노력이 필요함
- in  연산자에서 오류를 피하기 위해 먼저 객체임을 확인해야 하고, 
- typeof === 'object'이므로 별도로 null 이 아님을 확인해야 함


### 요약
- unknown은 any 대신 사용할 수 있는 안전한 타입
  - 어떠한 값이 있지만 그 타입을 알지 못하는 경우라면 unknown을 사용하면 됨
- 사용자가 타입 단언문이나 타입 체크를 사용하도록 강제하려면 unknown을 사용하면 됨
- {}, object, unknown의 차이점을 이해해야 함

## **43. 몽키 패치보다는 안전한 타입을 사용하기**
자바스크립트의 가장 큰 특징 중 하나는, 객체와 클래스에 임의의 속성을 추가할 수 있을만큼 유연하다는 것.

### 요약
- 전역 변수나 DOM에 데이터를 저장하지 말고, 데이터를 분리하여 사용해야 함
- 내장 타입에 데이터를 저장해야 하는 경우, 안전한 타입 접근법 중 하나를 사용해야 함
- 보강의 모듈 영역 문제를 이해해야 함

## **44. 타입 커버리지를 추적하여 타입 안전성 유지하기**


```bash
npx type-coverage

type-coverage@2.27.1
1245 / 1327 93.82%

type-coverage success.
```

### 요약
- noImplicitAny가 설정되어 있어도, 명시적 any 또는 서드파티 타입 선언을 통해 any 타입은 코드 내에 여전히 존재할 수 있다는 점을 주의해야 함
- 작성한 프로그램의 타입이 얼마나 잘 선언되었는지 추적해야 함
  - 추적함으로써 any의 사용을 줄여 나갈 수 있고, 타입 안정성을 꾸준히 높일 수 있음
