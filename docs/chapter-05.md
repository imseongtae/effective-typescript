# **Chapter-05**

any 다루기

## Table of contents
- [38. any 타입은 가능한 한 좁은 범위에서만 사용하기](#38-any-타입은-가능한-한-좁은-범위에서만-사용하기)
- [39. any를 구체적으로 변형해서 사용하기](#39-any를-구체적으로-변형해서-사용하기)
- [40. 함수 안으로 타입 단언문 감추기](#40-함수-안으로-타입-단언문-감추기)
- [41. any의 진화를 이해하기](#41-any의-진화를-이해하기)
- [42. 모르는 타입의 값에는 any 대신 unknown을 사용하기](#42-모르는-타입의-값에는-any-대신-unknown을-사용하기)
- [43. 몽키 패치보다는 안전한 타입을 사용하기](#43-몽키-패치보다는-안전한-타입을-사용하기)
- [44. 타입 커버리지를 추적하여 타입 안전성 유지하기](#44-타입-커버리지를-추적하여-타입-안전성-유지하기)

---

## **34. 부정확한 타입보다는 미완성 타입을 사용하기**

### 요약
- 타입 안정성에 대한 불쾌한 골짜기는 피해야 함. 타입이 없는 것보다 잘못된 것이 더 나쁨
- 정확하게 타입을 모델링할 수 없다면 부정확하게 모델링하지 말아야 함

---

## **35. 데이터가 아닌, API 명세를 보고 타입 만들기**

### 요약
- 코드의 구석구석까지 타입 안정성을 얻기 위해 API 또는 데이터 형식에 대한 타입 생성을 고려해야 함
- 데이터에 드러나지 않은 예외적인 경우들이 문제가 될 수 있으므로 명세로부터 코드를 생성하는 것이 좋음

---

## **36. 해당 분야의 용어로 타입 이름 짓기**

### 요약
- 가독성을 높이고, 추상화 수준을 올리기 위해 해당 분야의 용어를 사용해야 함
  - 타입 이름 짓기 역시 중요한 영역
  - 엄선된 타입, 속성, 변수의 이름은 의도를 명확히하고, 코드와 타입의 추상화 수준을 높여줌
- 같은 의미에서 다른 이름을 붙이면 안 됨.
  - 특별한 의미가 있을 때만 용어를 구분

### 정리
- 동일한 의미를 나타낼 때는 같은 용어의 사용
- 모호하고, 의미없는 이름은 피해야 함
- 이름을 지을 때는 데이터 자체가 무엇인지 고려해야 함

---

## **37. 공식 명칭에는 상표를 붙이기**

### 요약
- 타입스크립트는 구조적 타이핑을 사용하므로 값을 세밀하게 구분하지 못하는 경우가 있음
  - 값을 구분하기 위해 공식 명칭이 필요하다면 상표(brand)를 붙이는 것을 고려해야 함
- 상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있음

### 상표(_brand)를 사용하면 단순한 실수를 방지할 수 있다. 
물론 악의적인 사용을 막을 수는 없음

```ts
interface Vector2D {
  x: number;
  y: number;
  _brand: '2d';
}

const vector2D = (x: number, y: number): Vector2D => {
  return { x, y, _brand: '2d' };
};

const calculateNorm = (p: Vector2D) => {
  return Math.sqrt(p.x * p.x + p.y * p.y); // 기존과 동일
};

calculateNorm(vector2D(3, 4)); // 5
const vec3D = { x: 3, y: 4, z: 1 };

calculateNorm(vec3D); // 5
```



## **38. any 타입은 가능한 한 좁은 범위에서만 사용하기**

### 요약
- 의도치 않은 타입 안전성의 손실을 피하기 위해서 `any`의 사용 범위를 최소한으로 좁혀야 함
- 함수의 반환 타입이 `any`인 경우 타입 안정성이 나빠짐
  - 절대로 `any` 타입을 반환하면 안 됨
- 강제로 타입 오류를 제거하려면 `any` 대신 `@ts-ignore` 를 사용하는 것이 좋음

## **39. any를 구체적으로 변형해서 사용하기**

### 요약
- `any`를 사용할 때는 정말로 모든 값이 허용되어야만 하는지 면밀히 검토해야 함
- `any`보다 더 정확하게 모델링할 수 있도록 `any[]` 또는 `{[]: any}` 또는 `() => any`처럼 구체적인 형태를 사용해야 함


### 되도록 구체적으로 사용하자
- 함수내의 array.length 타입이 체크됨
- 함수의 반환 타입이 추론됨
- 함수 호출시 매개변수가 배열인지 체크됨

```ts
const getLength = (array: any[]) => array.length;
```

---

## **40. 함수 안으로 타입 단언문 감추기**

### 요약
- 타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 필요하기도 하고, 현실적인 해결책이 되기도 함
  - 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 해야 함

```ts
interface MyObject {
  [key: string]: any;
}

const isEqual = (obj1: MyObject, obj2: MyObject): boolean => {
  for (const key in obj1) {
    if (obj1.hasOwnProperty(key)) {
      // 단언문 사용
      const val1 = obj1[key];
      const val2 = obj2[key];

      // 객체의 동일한 키에 대해 값이 같은지 확인
      if (val1 !== val2) {
        return false;
      }
    }
  }
  return true;
};

const objA = { a: 1, b: '2' };
const objB = { a: 1, b: '2' };

console.log(isEqual(objA, objB)); // true
```


## **41. any의 진화를 이해하기**
any 타입의 진화는 암시적 any 타입에 어떤 값을 할당할 때만 발생.
어떤 변수가 암시적 any 상태일 때 값을 읽으려고 하면 오류가 발생함

### 요약
-
-

## **42. 모르는 타입의 값에는 any 대신 unknown을 사용하기**

### 요약
-
-

## **43. 몽키 패치보다는 안전한 타입을 사용하기**

### 요약
-
-

## **44. 타입 커버리지를 추적하여 타입 안전성 유지하기**

### 요약
-
-
