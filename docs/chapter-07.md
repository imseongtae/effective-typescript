# **Chapter-06**

any 다루기

## Table of contents
- [53. 타입스크립트 기능보다는 ECMAScript 기능을 사용하기](#53-타입스크립트-기능보다는-ecmascript-기능을-사용하기)

---

## **53. 타입스크립트 기능보다는 ECMAScript 기능을 사용하기**
TC39는 자바스크립트의 런타임 기능을 발전시키고, 타입스크립트팀은 타입 기능만 발전시킨다.


### 사용하지 않는 것이 좋은 기능
타입 공간(타입스크립트)과 값 공간(자바스크립트)의 경계를 혼란하게 만드는 기능은 사용하지 않는 것이 좋음

### Enum의 문제점
- 숫자 열거형에 0, 1, 2 외의 다른 숫자가 할당되면 매우 위험함
- 상수 열거형은 보통의 열거형과 달리 런타임에 완전히 제거됨
- 앞의 예제를 const enum Flavor로 바꾸면, 컴파일러는 Flavor.CHOCOLATE 을 0으로 바꿔버림
  - 문자열 열거형과 숫자형 열거형의 동작이 전혀 다름
- 문자열 열거형은 런타임의 타입 안정성과 투명성을 제공하지만 명목적 타이핑을 사용(다른 타입과 달리 구조적 타이핑이 아님)

#### 리터럴 타입의 유니온 열거형을 쓰세요
리터럴 타입의 유니ㅏ온은 열거형만큼 안전하며, 자바스크립트와 호환되는 장점이 있음

### 매개변수 속성
일반적으로 클래스를 초기화할 때 속성을 할당하기 위해 생성자의 매개변수를 사용

```ts
class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
}
```

타입스크립트는 더 간단한 문법을 제공하지만 문제점이 존재!

```ts
class Person {
  constructor(public name: string) {}
}
```

### 매개변수 속성의 문제점
- 일반적으로 타입스크립트 컴파일은 타입 제거가 이루어지므로 코드가 줄어들지만, 매개변수 속성을 코드가 늘어남
- 매개변수 속성이 런타임에 사용되지만, 타입스크립트 관점에서는 사용되지 않는 것처럼 보임
- 매개변수 속성과 일반 속성을 섞어서 사용하면 클래스의 설계가 혼란스러워짐


```ts
class Person {
  first: string;
  last: string;
  constructor(public name: string) {
    [this.first, this.last] = name.split(' ');
  }
}
```

- 클래스 설계가 혼란
- first, last만 속성에 나열되어 있으므로 일관성이 없음
- 한 가지만 사용하는 것이 좋음

### 네임스페이스와 트리플 슬래시 임포트

### 데코레이터
데코레이터는 클래스, 메서드, 속성에 애너테이션을 붙이거나 기능을 추가하는데 사용할 수 있음

### 요약
- 일반적으로 타입스크립트 코드에서 모든 타입 정보를 제거하면 자바스크립트가 됨.
  - 하지만 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 타입 정보를 제거한다고 자바스크립트가 되지는 않음
- 타입스크립트의 역할을 명확하게 하기 위해 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 사용하지 않는 것이 좋음

---

## **55. 객체를 순회하는 노하우**

### 요약
- 객체를 순회할 때, 키가 어떤 타입인지 정확히 파악하고 있다면, let k: keyof T와 for-in loop 를 사용
  - 함수의 매개변수로 쓰이는 객체에는 추가적인 키가 존재할 수 있다는 점을 명심
- 객체를 순회하며, 키와 값을 얻는 가장 일반적인 방법은 Object.entries를 사용하는 것